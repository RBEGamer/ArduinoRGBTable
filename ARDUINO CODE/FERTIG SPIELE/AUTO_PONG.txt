#include <FastSPI_LED.h>

#define NUM_LEDS 200


const unsigned int feldx = 20;
const unsigned int feldy = 10;

int ballx = feldx/2;
int bally = feldy/2;
int balldir = 4;
int player1score = 0;
int player2score = 0;

int paddle1x = 0; //final
int paddle2x = feldx-1;
int paddle1y = 0;
int paddle2y = 0;
int paddle1size = 3;
int paddle2size = 3;

int tmp_paddle1y = 0;
int tmp_paddle2y = 0;

// Sometimes chipsets wire in a backwards sort of way
struct CRGB { unsigned char b; unsigned char r; unsigned char g; };
// struct CRGB { unsigned char r; unsigned char g; unsigned char b; };
struct CRGB *leds;

#define PIN 6

void setup()
{
  randomSeed(analogRead(0));
  FastSPI_LED.setLeds(NUM_LEDS);
  FastSPI_LED.setChipset(CFastSPI_LED::SPI_TM1809);
  FastSPI_LED.setPin(PIN);
  FastSPI_LED.setDataRate(1);
  FastSPI_LED.init();
  FastSPI_LED.start();
  leds = (struct CRGB*)FastSPI_LED.getRGBData(); 
  reset_game();
}

void loop() { 
//DELETE
        leds[get_led_number(ballx,bally)].r = 0;
        leds[get_led_number(ballx,bally)].g = 0;
        leds[get_led_number(ballx,bally)].b = 0;   
        for (int i=0; i<paddle1size; i++){
  leds[get_led_number(paddle1x,i+paddle1y)].r = 0;
        leds[get_led_number(paddle1x,i+paddle1y)].g = 0;
        leds[get_led_number(paddle1x,i+paddle1y)].b = 0;
}
                for (int i=0; i<paddle2size; i++){
                leds[get_led_number(paddle2x,i+paddle2y)].r = 0;
                leds[get_led_number(paddle2x,i+paddle2y)].g = 0;
                leds[get_led_number(paddle2x,i+paddle2y)].b = 0;
                }
      
   //BALL LOGIC    
   switch (balldir) {
    case 0: 
        ballx = ballx;
        bally = bally;
      break;    
      case 1:     
        ballx = ballx+1;
        bally = bally+1; 
      break;   
     case 2:    
        ballx = ballx-1;
        bally = bally-1; 
      break;     
     case 3:       
        ballx = ballx+1;
        bally = bally-1;
      break;
     case 4:   
        ballx = ballx-1;
        bally = bally+1; 
      break;   
    default:    
        ballx = ballx;
        bally = bally;
      break;
  }
      
      
      if(bally <= 0){
        if(balldir == 2){
      balldir = 4; 
        }else if(balldir == 3){
        balldir = 1; 
        }        
      }else if(bally >= feldy-1){
       if(balldir == 1){
      balldir = 3; 
        }else if(balldir == 4){
        balldir = 2; 
        }        
      }else if(ballx <= 0){
       // LOOSER P2
           player1score++;
           reset_game();     
      }else if(ballx >= feldx-1){
      //LOOSER P1
      player2score++;
      reset_game();
      }  
      
      
//PADDLE BOUNCE INCL CORNERCORRECTION
if(ballx == paddle1x+1){
 for (int i=paddle1y-1; i<paddle1y + paddle1size + 1; i++){
   if(bally == i){
 if(balldir == 2){
 balldir = 3;
 }else if(balldir == 4){
 balldir = 1;
 }else{
 reset_game();
 }
   }//bally == i
 }//for
}//if ballx = paddle
     
       
if(ballx == paddle2x-1){
 for (int i=paddle1y-1; i<paddle2y + paddle2size + 1; i++){
   if(bally == i){
 if(balldir == 1){
 balldir = 4;
 }else if(balldir == 3){
 balldir = 2;
 }else{
 reset_game();
 }
   }//bally == i
 }//for
}//if ballx = paddle

      
      tmp_paddle1y = bally-paddle1size/2;  //HIER PADDLEPOS ÄNDERN
      if(tmp_paddle1y < 0){tmp_paddle1y = 0;}
      if(tmp_paddle1y > feldy-paddle1size){
      tmp_paddle1y = feldy-paddle1size;
      }
      
      tmp_paddle2y = bally-paddle2size/2;  //HIER PADDLEPOS ÄNDERN
      if(tmp_paddle2y < 0){tmp_paddle2y = 0;}
      if(tmp_paddle2y > feldy-paddle2size){
      tmp_paddle2y = feldy-paddle2size;
      }
      
      paddle1y = tmp_paddle1y;
      paddle2y = tmp_paddle2y;
     

      
      
      
      
      //DRAW 
     
        
        
        
                for (int i=0; i<paddle1size; i++){
                leds[get_led_number(paddle1x,i+paddle1y)].r = 0;
                leds[get_led_number(paddle1x,i + paddle1y)].g = 255;
                leds[get_led_number(paddle1x,i+paddle1y)].b = 0;
                }
                
                 for (int i=0; i<paddle2size; i++){
                leds[get_led_number(paddle2x,i+paddle2y)].r = 0;
                leds[get_led_number(paddle2x,i+paddle2y)].g = 0;
                leds[get_led_number(paddle2x,i+paddle2y)].b = 255;
                }
                
                
                
                
                
                
                
                
                   leds[get_led_number(ballx,bally)].r = 255;
        leds[get_led_number(ballx,bally)].g = 0;
        leds[get_led_number(ballx,bally)].b = 0;
 FastSPI_LED.show();
 
 delay(300);
}

unsigned int get_led_number(int x, int y){
 if (y % 2) {
  return (y*feldx)+feldx-1-x; //ungerade
} else {
  return (y*feldx)+x; //y=1; //GERADE
} 
}


void reset_game(){
ballx = feldx/2;
bally = feldy/2;
balldir =  random(1, 5);
}